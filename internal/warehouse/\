package warehouse

import (
	"bufio"
	"fmt"
	"net"
	"strconv"
	"strings"
	"github.com/mariuskimmina/supplywatch/pkg/logger"
)

type warehouse struct {

}

func NewWarehouse() *warehouse {
    return &warehouse{}
}

var (
    address = "0.0.0.0:1234"
)

const (
    maxBufferSize = 1024
)

func (w *warehouse) Start() {
    //ctx := context.Background()
    logger.Debug("Starting warehouse")
    //listen, err := net.ListenPacket("udp", address)
    //if err != nil {
        //return
    //}
    //defer listen.Close()
    ln, err := net.Listen("tcp", "127.0.0.1:8000")
    if err != nil {
        logger.Error(err.Error())
        return
    }
    defer ln.Close()
    for {
        logger.Debug("Warehouse running")
        c, err := ln.Accept()
        if err != nil {
            logger.Error(err.Error())
            return
        }
        go handleConnection(c)
    }
}

type HTTPRequest struct {
    method  string
    path    string
    version string
}

func handleConnection(c net.Conn) {
    fmt.Printf("Serving %s\n", c.RemoteAddr().String())
    for {
        netData, err := bufio.NewReader(c).ReadString('\n')
        if err != nil {
                fmt.Println(err)
                return
        }
        requestData := strings.Split(netData, " ")
        request := HTTPRequest{
            method:     requestData[0],
            path:       requestData[1],
            version:    requestData[2],
        } 

        fmt.Println(request.method)
        fmt.Println(request.path)
        fmt.Println(request.version)
        result := strconv.Itoa(1234) + "\n"
        c.Write([]byte(string(result)))
        c.Close()
    }
}

